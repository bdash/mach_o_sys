/* automatically generated by rust-bindgen 0.70.1 */

#![allow(
    dead_code,
    non_camel_case_types,
    non_upper_case_globals,
    non_snake_case
)]
use crate::loader::*;

pub const NSLINKMODULE_OPTION_NONE: u32 = 0;
pub const NSLINKMODULE_OPTION_BINDNOW: u32 = 1;
pub const NSLINKMODULE_OPTION_PRIVATE: u32 = 2;
pub const NSLINKMODULE_OPTION_RETURN_ON_ERROR: u32 = 4;
pub const NSLINKMODULE_OPTION_DONT_CALL_MOD_INIT_ROUTINES: u32 = 8;
pub const NSLINKMODULE_OPTION_TRAILING_PHYS_NAME: u32 = 16;
pub const NSUNLINKMODULE_OPTION_NONE: u32 = 0;
pub const NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED: u32 = 1;
pub const NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES: u32 = 2;
pub const NSLOOKUPSYMBOLINIMAGE_OPTION_BIND: u32 = 0;
pub const NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW: u32 = 1;
pub const NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_FULLY: u32 = 2;
pub const NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR: u32 = 4;
pub const NSADDIMAGE_OPTION_NONE: u32 = 0;
pub const NSADDIMAGE_OPTION_RETURN_ON_ERROR: u32 = 1;
pub const NSADDIMAGE_OPTION_WITH_SEARCHING: u32 = 2;
pub const NSADDIMAGE_OPTION_RETURN_ONLY_IF_LOADED: u32 = 4;
pub const NSADDIMAGE_OPTION_MATCH_FILENAME_BY_INSTALLNAME: u32 = 8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DYLD_BOOL {
    FALSE = 0,
    TRUE = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NSObjectFileImageReturnCode {
    NSObjectFileImageFailure = 0,
    NSObjectFileImageSuccess = 1,
    NSObjectFileImageInappropriateFile = 2,
    NSObjectFileImageArch = 3,
    NSObjectFileImageFormat = 4,
    NSObjectFileImageAccess = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NSObjectFileImage {
    _unused: [u8; 0],
}
pub type NSObjectFileImage = *mut __NSObjectFileImage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NSModule {
    _unused: [u8; 0],
}
pub type NSModule = *mut __NSModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __NSSymbol {
    _unused: [u8; 0],
}
pub type NSSymbol = *mut __NSSymbol;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NSLinkEditErrors {
    NSLinkEditFileAccessError = 0,
    NSLinkEditFileFormatError = 1,
    NSLinkEditMachResourceError = 2,
    NSLinkEditUnixResourceError = 3,
    NSLinkEditOtherError = 4,
    NSLinkEditWarningError = 5,
    NSLinkEditMultiplyDefinedError = 6,
    NSLinkEditUndefinedError = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NSOtherErrorNumbers {
    NSOtherErrorRelocation = 0,
    NSOtherErrorLazyBind = 1,
    NSOtherErrorIndrLoop = 2,
    NSOtherErrorLazyInit = 3,
    NSOtherErrorInvalidArgs = 4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NSLinkEditErrorHandlers {
    pub undefined:
        ::std::option::Option<unsafe extern "C" fn(symbolName: *const ::std::os::raw::c_char)>,
    pub multiple: ::std::option::Option<
        unsafe extern "C" fn(s: NSSymbol, oldModule: NSModule, newModule: NSModule) -> NSModule,
    >,
    pub linkEdit: ::std::option::Option<
        unsafe extern "C" fn(
            errorClass: NSLinkEditErrors,
            errorNumber: ::std::os::raw::c_int,
            fileName: *const ::std::os::raw::c_char,
            errorString: *const ::std::os::raw::c_char,
        ),
    >,
}
extern "C" {
    pub fn _dyld_image_count() -> u32;
    pub fn _dyld_get_image_header(image_index: u32) -> *const mach_header;
    pub fn _dyld_get_image_vmaddr_slide(image_index: u32) -> isize;
    pub fn _dyld_get_image_name(image_index: u32) -> *const ::std::os::raw::c_char;
    pub fn _dyld_register_func_for_add_image(
        func: ::std::option::Option<
            unsafe extern "C" fn(mh: *const mach_header, vmaddr_slide: isize),
        >,
    );
    pub fn _dyld_register_func_for_remove_image(
        func: ::std::option::Option<
            unsafe extern "C" fn(mh: *const mach_header, vmaddr_slide: isize),
        >,
    );
    pub fn NSVersionOfRunTimeLibrary(libraryName: *const ::std::os::raw::c_char) -> i32;
    pub fn NSVersionOfLinkTimeLibrary(libraryName: *const ::std::os::raw::c_char) -> i32;
    pub fn _NSGetExecutablePath(
        buf: *mut ::std::os::raw::c_char,
        bufsize: *mut u32,
    ) -> ::std::os::raw::c_int;
    pub fn _tlv_atexit(
        termFunc: ::std::option::Option<unsafe extern "C" fn(objAddr: *mut ::std::os::raw::c_void)>,
        objAddr: *mut ::std::os::raw::c_void,
    );
    pub fn _tlv_bootstrap();
    pub fn _dyld_shared_cache_contains_path(path: *const ::std::os::raw::c_char) -> bool;
    pub fn NSCreateObjectFileImageFromFile(
        pathName: *const ::std::os::raw::c_char,
        objectFileImage: *mut NSObjectFileImage,
    ) -> NSObjectFileImageReturnCode;
    pub fn NSCreateObjectFileImageFromMemory(
        address: *const ::std::os::raw::c_void,
        size: usize,
        objectFileImage: *mut NSObjectFileImage,
    ) -> NSObjectFileImageReturnCode;
    pub fn NSDestroyObjectFileImage(objectFileImage: NSObjectFileImage) -> bool;
    pub fn NSSymbolDefinitionCountInObjectFileImage(objectFileImage: NSObjectFileImage) -> u32;
    pub fn NSSymbolDefinitionNameInObjectFileImage(
        objectFileImage: NSObjectFileImage,
        ordinal: u32,
    ) -> *const ::std::os::raw::c_char;
    pub fn NSSymbolReferenceCountInObjectFileImage(objectFileImage: NSObjectFileImage) -> u32;
    pub fn NSSymbolReferenceNameInObjectFileImage(
        objectFileImage: NSObjectFileImage,
        ordinal: u32,
        tentative_definition: *mut bool,
    ) -> *const ::std::os::raw::c_char;
    pub fn NSIsSymbolDefinedInObjectFileImage(
        objectFileImage: NSObjectFileImage,
        symbolName: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn NSGetSectionDataInObjectFileImage(
        objectFileImage: NSObjectFileImage,
        segmentName: *const ::std::os::raw::c_char,
        sectionName: *const ::std::os::raw::c_char,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
    pub fn NSNameOfModule(m: NSModule) -> *const ::std::os::raw::c_char;
    pub fn NSLibraryNameForModule(m: NSModule) -> *const ::std::os::raw::c_char;
    pub fn NSLinkModule(
        objectFileImage: NSObjectFileImage,
        moduleName: *const ::std::os::raw::c_char,
        options: u32,
    ) -> NSModule;
    pub fn NSUnLinkModule(module: NSModule, options: u32) -> bool;
    pub fn NSIsSymbolNameDefined(symbolName: *const ::std::os::raw::c_char) -> bool;
    pub fn NSIsSymbolNameDefinedWithHint(
        symbolName: *const ::std::os::raw::c_char,
        libraryNameHint: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn NSIsSymbolNameDefinedInImage(
        image: *const mach_header,
        symbolName: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn NSLookupAndBindSymbol(symbolName: *const ::std::os::raw::c_char) -> NSSymbol;
    pub fn NSLookupAndBindSymbolWithHint(
        symbolName: *const ::std::os::raw::c_char,
        libraryNameHint: *const ::std::os::raw::c_char,
    ) -> NSSymbol;
    pub fn NSLookupSymbolInModule(
        module: NSModule,
        symbolName: *const ::std::os::raw::c_char,
    ) -> NSSymbol;
    pub fn NSLookupSymbolInImage(
        image: *const mach_header,
        symbolName: *const ::std::os::raw::c_char,
        options: u32,
    ) -> NSSymbol;
    pub fn NSNameOfSymbol(symbol: NSSymbol) -> *const ::std::os::raw::c_char;
    pub fn NSAddressOfSymbol(symbol: NSSymbol) -> *mut ::std::os::raw::c_void;
    pub fn NSModuleForSymbol(symbol: NSSymbol) -> NSModule;
    pub fn NSLinkEditError(
        c: *mut NSLinkEditErrors,
        errorNumber: *mut ::std::os::raw::c_int,
        fileName: *mut *const ::std::os::raw::c_char,
        errorString: *mut *const ::std::os::raw::c_char,
    );
    pub fn NSInstallLinkEditErrorHandlers(handlers: *const NSLinkEditErrorHandlers);
    pub fn NSAddLibrary(pathName: *const ::std::os::raw::c_char) -> bool;
    pub fn NSAddLibraryWithSearching(pathName: *const ::std::os::raw::c_char) -> bool;
    pub fn NSAddImage(
        image_name: *const ::std::os::raw::c_char,
        options: u32,
    ) -> *const mach_header;
    pub fn _dyld_present() -> bool;
    pub fn _dyld_launched_prebound() -> bool;
    pub fn _dyld_all_twolevel_modules_prebound() -> bool;
    pub fn _dyld_bind_fully_image_containing_address(
        address: *const ::std::os::raw::c_void,
    ) -> bool;
    pub fn _dyld_image_containing_address(address: *const ::std::os::raw::c_void) -> bool;
    pub fn _dyld_lookup_and_bind(
        symbol_name: *const ::std::os::raw::c_char,
        address: *mut *mut ::std::os::raw::c_void,
        module: *mut NSModule,
    );
    pub fn _dyld_lookup_and_bind_with_hint(
        symbol_name: *const ::std::os::raw::c_char,
        library_name_hint: *const ::std::os::raw::c_char,
        address: *mut *mut ::std::os::raw::c_void,
        module: *mut NSModule,
    );
    pub fn _dyld_lookup_and_bind_fully(
        symbol_name: *const ::std::os::raw::c_char,
        address: *mut *mut ::std::os::raw::c_void,
        module: *mut NSModule,
    );
    pub fn _dyld_get_image_header_containing_address(
        address: *const ::std::os::raw::c_void,
    ) -> *const mach_header;
}
