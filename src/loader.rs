/* automatically generated by rust-bindgen 0.70.1 */

#![allow(
    dead_code,
    non_camel_case_types,
    non_upper_case_globals,
    non_snake_case
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MH_MAGIC: u32 = 4277009102;
pub const MH_CIGAM: u32 = 3472551422;
pub const MH_MAGIC_64: u32 = 4277009103;
pub const MH_CIGAM_64: u32 = 3489328638;
pub const MH_OBJECT: u32 = 1;
pub const MH_EXECUTE: u32 = 2;
pub const MH_FVMLIB: u32 = 3;
pub const MH_CORE: u32 = 4;
pub const MH_PRELOAD: u32 = 5;
pub const MH_DYLIB: u32 = 6;
pub const MH_DYLINKER: u32 = 7;
pub const MH_BUNDLE: u32 = 8;
pub const MH_DYLIB_STUB: u32 = 9;
pub const MH_DSYM: u32 = 10;
pub const MH_KEXT_BUNDLE: u32 = 11;
pub const MH_FILESET: u32 = 12;
pub const MH_GPU_EXECUTE: u32 = 13;
pub const MH_GPU_DYLIB: u32 = 14;
pub const MH_NOUNDEFS: u32 = 1;
pub const MH_INCRLINK: u32 = 2;
pub const MH_DYLDLINK: u32 = 4;
pub const MH_BINDATLOAD: u32 = 8;
pub const MH_PREBOUND: u32 = 16;
pub const MH_SPLIT_SEGS: u32 = 32;
pub const MH_LAZY_INIT: u32 = 64;
pub const MH_TWOLEVEL: u32 = 128;
pub const MH_FORCE_FLAT: u32 = 256;
pub const MH_NOMULTIDEFS: u32 = 512;
pub const MH_NOFIXPREBINDING: u32 = 1024;
pub const MH_PREBINDABLE: u32 = 2048;
pub const MH_ALLMODSBOUND: u32 = 4096;
pub const MH_SUBSECTIONS_VIA_SYMBOLS: u32 = 8192;
pub const MH_CANONICAL: u32 = 16384;
pub const MH_WEAK_DEFINES: u32 = 32768;
pub const MH_BINDS_TO_WEAK: u32 = 65536;
pub const MH_ALLOW_STACK_EXECUTION: u32 = 131072;
pub const MH_ROOT_SAFE: u32 = 262144;
pub const MH_SETUID_SAFE: u32 = 524288;
pub const MH_NO_REEXPORTED_DYLIBS: u32 = 1048576;
pub const MH_PIE: u32 = 2097152;
pub const MH_DEAD_STRIPPABLE_DYLIB: u32 = 4194304;
pub const MH_HAS_TLV_DESCRIPTORS: u32 = 8388608;
pub const MH_NO_HEAP_EXECUTION: u32 = 16777216;
pub const MH_APP_EXTENSION_SAFE: u32 = 33554432;
pub const MH_NLIST_OUTOFSYNC_WITH_DYLDINFO: u32 = 67108864;
pub const MH_SIM_SUPPORT: u32 = 134217728;
pub const MH_IMPLICIT_PAGEZERO: u32 = 268435456;
pub const MH_DYLIB_IN_CACHE: u32 = 2147483648;
pub const LC_REQ_DYLD: u32 = 2147483648;
pub const LC_SEGMENT: u32 = 1;
pub const LC_SYMTAB: u32 = 2;
pub const LC_SYMSEG: u32 = 3;
pub const LC_THREAD: u32 = 4;
pub const LC_UNIXTHREAD: u32 = 5;
pub const LC_LOADFVMLIB: u32 = 6;
pub const LC_IDFVMLIB: u32 = 7;
pub const LC_IDENT: u32 = 8;
pub const LC_FVMFILE: u32 = 9;
pub const LC_PREPAGE: u32 = 10;
pub const LC_DYSYMTAB: u32 = 11;
pub const LC_LOAD_DYLIB: u32 = 12;
pub const LC_ID_DYLIB: u32 = 13;
pub const LC_LOAD_DYLINKER: u32 = 14;
pub const LC_ID_DYLINKER: u32 = 15;
pub const LC_PREBOUND_DYLIB: u32 = 16;
pub const LC_ROUTINES: u32 = 17;
pub const LC_SUB_FRAMEWORK: u32 = 18;
pub const LC_SUB_UMBRELLA: u32 = 19;
pub const LC_SUB_CLIENT: u32 = 20;
pub const LC_SUB_LIBRARY: u32 = 21;
pub const LC_TWOLEVEL_HINTS: u32 = 22;
pub const LC_PREBIND_CKSUM: u32 = 23;
pub const LC_LOAD_WEAK_DYLIB: u32 = 2147483672;
pub const LC_SEGMENT_64: u32 = 25;
pub const LC_ROUTINES_64: u32 = 26;
pub const LC_UUID: u32 = 27;
pub const LC_RPATH: u32 = 2147483676;
pub const LC_CODE_SIGNATURE: u32 = 29;
pub const LC_SEGMENT_SPLIT_INFO: u32 = 30;
pub const LC_REEXPORT_DYLIB: u32 = 2147483679;
pub const LC_LAZY_LOAD_DYLIB: u32 = 32;
pub const LC_ENCRYPTION_INFO: u32 = 33;
pub const LC_DYLD_INFO: u32 = 34;
pub const LC_DYLD_INFO_ONLY: u32 = 2147483682;
pub const LC_LOAD_UPWARD_DYLIB: u32 = 2147483683;
pub const LC_VERSION_MIN_MACOSX: u32 = 36;
pub const LC_VERSION_MIN_IPHONEOS: u32 = 37;
pub const LC_FUNCTION_STARTS: u32 = 38;
pub const LC_DYLD_ENVIRONMENT: u32 = 39;
pub const LC_MAIN: u32 = 2147483688;
pub const LC_DATA_IN_CODE: u32 = 41;
pub const LC_SOURCE_VERSION: u32 = 42;
pub const LC_DYLIB_CODE_SIGN_DRS: u32 = 43;
pub const LC_ENCRYPTION_INFO_64: u32 = 44;
pub const LC_LINKER_OPTION: u32 = 45;
pub const LC_LINKER_OPTIMIZATION_HINT: u32 = 46;
pub const LC_VERSION_MIN_TVOS: u32 = 47;
pub const LC_VERSION_MIN_WATCHOS: u32 = 48;
pub const LC_NOTE: u32 = 49;
pub const LC_BUILD_VERSION: u32 = 50;
pub const LC_DYLD_EXPORTS_TRIE: u32 = 2147483699;
pub const LC_DYLD_CHAINED_FIXUPS: u32 = 2147483700;
pub const LC_FILESET_ENTRY: u32 = 2147483701;
pub const LC_ATOM_INFO: u32 = 54;
pub const SG_HIGHVM: u32 = 1;
pub const SG_FVMLIB: u32 = 2;
pub const SG_NORELOC: u32 = 4;
pub const SG_PROTECTED_VERSION_1: u32 = 8;
pub const SG_READ_ONLY: u32 = 16;
pub const SECTION_TYPE: u32 = 255;
pub const SECTION_ATTRIBUTES: u32 = 4294967040;
pub const S_REGULAR: u32 = 0;
pub const S_ZEROFILL: u32 = 1;
pub const S_CSTRING_LITERALS: u32 = 2;
pub const S_4BYTE_LITERALS: u32 = 3;
pub const S_8BYTE_LITERALS: u32 = 4;
pub const S_LITERAL_POINTERS: u32 = 5;
pub const S_NON_LAZY_SYMBOL_POINTERS: u32 = 6;
pub const S_LAZY_SYMBOL_POINTERS: u32 = 7;
pub const S_SYMBOL_STUBS: u32 = 8;
pub const S_MOD_INIT_FUNC_POINTERS: u32 = 9;
pub const S_MOD_TERM_FUNC_POINTERS: u32 = 10;
pub const S_COALESCED: u32 = 11;
pub const S_GB_ZEROFILL: u32 = 12;
pub const S_INTERPOSING: u32 = 13;
pub const S_16BYTE_LITERALS: u32 = 14;
pub const S_DTRACE_DOF: u32 = 15;
pub const S_LAZY_DYLIB_SYMBOL_POINTERS: u32 = 16;
pub const S_THREAD_LOCAL_REGULAR: u32 = 17;
pub const S_THREAD_LOCAL_ZEROFILL: u32 = 18;
pub const S_THREAD_LOCAL_VARIABLES: u32 = 19;
pub const S_THREAD_LOCAL_VARIABLE_POINTERS: u32 = 20;
pub const S_THREAD_LOCAL_INIT_FUNCTION_POINTERS: u32 = 21;
pub const S_INIT_FUNC_OFFSETS: u32 = 22;
pub const SECTION_ATTRIBUTES_USR: u32 = 4278190080;
pub const S_ATTR_PURE_INSTRUCTIONS: u32 = 2147483648;
pub const S_ATTR_NO_TOC: u32 = 1073741824;
pub const S_ATTR_STRIP_STATIC_SYMS: u32 = 536870912;
pub const S_ATTR_NO_DEAD_STRIP: u32 = 268435456;
pub const S_ATTR_LIVE_SUPPORT: u32 = 134217728;
pub const S_ATTR_SELF_MODIFYING_CODE: u32 = 67108864;
pub const S_ATTR_DEBUG: u32 = 33554432;
pub const SECTION_ATTRIBUTES_SYS: u32 = 16776960;
pub const S_ATTR_SOME_INSTRUCTIONS: u32 = 1024;
pub const S_ATTR_EXT_RELOC: u32 = 512;
pub const S_ATTR_LOC_RELOC: u32 = 256;
pub const SEG_PAGEZERO: &[u8; 11] = b"__PAGEZERO\0";
pub const SEG_TEXT: &[u8; 7] = b"__TEXT\0";
pub const SECT_TEXT: &[u8; 7] = b"__text\0";
pub const SECT_FVMLIB_INIT0: &[u8; 15] = b"__fvmlib_init0\0";
pub const SECT_FVMLIB_INIT1: &[u8; 15] = b"__fvmlib_init1\0";
pub const SEG_DATA: &[u8; 7] = b"__DATA\0";
pub const SECT_DATA: &[u8; 7] = b"__data\0";
pub const SECT_BSS: &[u8; 6] = b"__bss\0";
pub const SECT_COMMON: &[u8; 9] = b"__common\0";
pub const SEG_OBJC: &[u8; 7] = b"__OBJC\0";
pub const SECT_OBJC_SYMBOLS: &[u8; 15] = b"__symbol_table\0";
pub const SECT_OBJC_MODULES: &[u8; 14] = b"__module_info\0";
pub const SECT_OBJC_STRINGS: &[u8; 16] = b"__selector_strs\0";
pub const SECT_OBJC_REFS: &[u8; 16] = b"__selector_refs\0";
pub const SEG_ICON: &[u8; 7] = b"__ICON\0";
pub const SECT_ICON_HEADER: &[u8; 9] = b"__header\0";
pub const SECT_ICON_TIFF: &[u8; 7] = b"__tiff\0";
pub const SEG_LINKEDIT: &[u8; 11] = b"__LINKEDIT\0";
pub const SEG_UNIXSTACK: &[u8; 12] = b"__UNIXSTACK\0";
pub const SEG_IMPORT: &[u8; 9] = b"__IMPORT\0";
pub const DYLIB_USE_WEAK_LINK: u32 = 1;
pub const DYLIB_USE_REEXPORT: u32 = 2;
pub const DYLIB_USE_UPWARD: u32 = 4;
pub const DYLIB_USE_DELAYED_INIT: u32 = 8;
pub const DYLIB_USE_MARKER: u32 = 443815936;
pub const INDIRECT_SYMBOL_LOCAL: u32 = 2147483648;
pub const INDIRECT_SYMBOL_ABS: u32 = 1073741824;
pub const PLATFORM_UNKNOWN: u32 = 0;
pub const PLATFORM_ANY: u32 = 4294967295;
pub const PLATFORM_MACOS: u32 = 1;
pub const PLATFORM_IOS: u32 = 2;
pub const PLATFORM_TVOS: u32 = 3;
pub const PLATFORM_WATCHOS: u32 = 4;
pub const PLATFORM_BRIDGEOS: u32 = 5;
pub const PLATFORM_MACCATALYST: u32 = 6;
pub const PLATFORM_IOSSIMULATOR: u32 = 7;
pub const PLATFORM_TVOSSIMULATOR: u32 = 8;
pub const PLATFORM_WATCHOSSIMULATOR: u32 = 9;
pub const PLATFORM_DRIVERKIT: u32 = 10;
pub const PLATFORM_VISIONOS: u32 = 11;
pub const PLATFORM_VISIONOSSIMULATOR: u32 = 12;
pub const PLATFORM_FIRMWARE: u32 = 13;
pub const PLATFORM_SEPOS: u32 = 14;
pub const TOOL_CLANG: u32 = 1;
pub const TOOL_SWIFT: u32 = 2;
pub const TOOL_LD: u32 = 3;
pub const TOOL_LLD: u32 = 4;
pub const TOOL_METAL: u32 = 1024;
pub const TOOL_AIRLLD: u32 = 1025;
pub const TOOL_AIRNT: u32 = 1026;
pub const TOOL_AIRNT_PLUGIN: u32 = 1027;
pub const TOOL_AIRPACK: u32 = 1028;
pub const TOOL_GPUARCHIVER: u32 = 1031;
pub const TOOL_METAL_FRAMEWORK: u32 = 1032;
pub const REBASE_TYPE_POINTER: u32 = 1;
pub const REBASE_TYPE_TEXT_ABSOLUTE32: u32 = 2;
pub const REBASE_TYPE_TEXT_PCREL32: u32 = 3;
pub const REBASE_OPCODE_MASK: u32 = 240;
pub const REBASE_IMMEDIATE_MASK: u32 = 15;
pub const REBASE_OPCODE_DONE: u32 = 0;
pub const REBASE_OPCODE_SET_TYPE_IMM: u32 = 16;
pub const REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: u32 = 32;
pub const REBASE_OPCODE_ADD_ADDR_ULEB: u32 = 48;
pub const REBASE_OPCODE_ADD_ADDR_IMM_SCALED: u32 = 64;
pub const REBASE_OPCODE_DO_REBASE_IMM_TIMES: u32 = 80;
pub const REBASE_OPCODE_DO_REBASE_ULEB_TIMES: u32 = 96;
pub const REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB: u32 = 112;
pub const REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB: u32 = 128;
pub const BIND_TYPE_POINTER: u32 = 1;
pub const BIND_TYPE_TEXT_ABSOLUTE32: u32 = 2;
pub const BIND_TYPE_TEXT_PCREL32: u32 = 3;
pub const BIND_SPECIAL_DYLIB_SELF: u32 = 0;
pub const BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE: i32 = -1;
pub const BIND_SPECIAL_DYLIB_FLAT_LOOKUP: i32 = -2;
pub const BIND_SPECIAL_DYLIB_WEAK_LOOKUP: i32 = -3;
pub const BIND_SYMBOL_FLAGS_WEAK_IMPORT: u32 = 1;
pub const BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION: u32 = 8;
pub const BIND_OPCODE_MASK: u32 = 240;
pub const BIND_IMMEDIATE_MASK: u32 = 15;
pub const BIND_OPCODE_DONE: u32 = 0;
pub const BIND_OPCODE_SET_DYLIB_ORDINAL_IMM: u32 = 16;
pub const BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB: u32 = 32;
pub const BIND_OPCODE_SET_DYLIB_SPECIAL_IMM: u32 = 48;
pub const BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: u32 = 64;
pub const BIND_OPCODE_SET_TYPE_IMM: u32 = 80;
pub const BIND_OPCODE_SET_ADDEND_SLEB: u32 = 96;
pub const BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB: u32 = 112;
pub const BIND_OPCODE_ADD_ADDR_ULEB: u32 = 128;
pub const BIND_OPCODE_DO_BIND: u32 = 144;
pub const BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB: u32 = 160;
pub const BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED: u32 = 176;
pub const BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB: u32 = 192;
pub const BIND_OPCODE_THREADED: u32 = 208;
pub const BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: u32 = 0;
pub const BIND_SUBOPCODE_THREADED_APPLY: u32 = 1;
pub const EXPORT_SYMBOL_FLAGS_KIND_MASK: u32 = 3;
pub const EXPORT_SYMBOL_FLAGS_KIND_REGULAR: u32 = 0;
pub const EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL: u32 = 1;
pub const EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE: u32 = 2;
pub const EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION: u32 = 4;
pub const EXPORT_SYMBOL_FLAGS_REEXPORT: u32 = 8;
pub const EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER: u32 = 16;
pub const EXPORT_SYMBOL_FLAGS_STATIC_RESOLVER: u32 = 32;
pub const DICE_KIND_DATA: u32 = 1;
pub const DICE_KIND_JUMP_TABLE8: u32 = 2;
pub const DICE_KIND_JUMP_TABLE16: u32 = 3;
pub const DICE_KIND_JUMP_TABLE32: u32 = 4;
pub const DICE_KIND_ABS_JUMP_TABLE32: u32 = 5;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_header {
    pub magic: u32,
    pub cputype: i32,
    pub cpusubtype: i32,
    pub filetype: u32,
    pub ncmds: u32,
    pub sizeofcmds: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct mach_header_64 {
    pub magic: u32,
    pub cputype: i32,
    pub cpusubtype: i32,
    pub filetype: u32,
    pub ncmds: u32,
    pub sizeofcmds: u32,
    pub flags: u32,
    pub reserved: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct load_command {
    pub cmd: u32,
    pub cmdsize: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lc_str {
    pub offset: u32,
}
impl Default for lc_str {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct segment_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub segname: [::std::os::raw::c_char; 16usize],
    pub vmaddr: u32,
    pub vmsize: u32,
    pub fileoff: u32,
    pub filesize: u32,
    pub maxprot: i32,
    pub initprot: i32,
    pub nsects: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct segment_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub segname: [::std::os::raw::c_char; 16usize],
    pub vmaddr: u64,
    pub vmsize: u64,
    pub fileoff: u64,
    pub filesize: u64,
    pub maxprot: i32,
    pub initprot: i32,
    pub nsects: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct section {
    pub sectname: [::std::os::raw::c_char; 16usize],
    pub segname: [::std::os::raw::c_char; 16usize],
    pub addr: u32,
    pub size: u32,
    pub offset: u32,
    pub align: u32,
    pub reloff: u32,
    pub nreloc: u32,
    pub flags: u32,
    pub reserved1: u32,
    pub reserved2: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct section_64 {
    pub sectname: [::std::os::raw::c_char; 16usize],
    pub segname: [::std::os::raw::c_char; 16usize],
    pub addr: u64,
    pub size: u64,
    pub offset: u32,
    pub align: u32,
    pub reloff: u32,
    pub nreloc: u32,
    pub flags: u32,
    pub reserved1: u32,
    pub reserved2: u32,
    pub reserved3: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fvmlib {
    pub name: lc_str,
    pub minor_version: u32,
    pub header_addr: u32,
}
impl Default for fvmlib {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fvmlib_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub fvmlib: fvmlib,
}
impl Default for fvmlib_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dylib {
    pub name: lc_str,
    pub timestamp: u32,
    pub current_version: u32,
    pub compatibility_version: u32,
}
impl Default for dylib {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dylib_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub dylib: dylib,
}
impl Default for dylib_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dylib_use_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub nameoff: u32,
    pub marker: u32,
    pub current_version: u32,
    pub compat_version: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_framework_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub umbrella: lc_str,
}
impl Default for sub_framework_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_client_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub client: lc_str,
}
impl Default for sub_client_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_umbrella_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub sub_umbrella: lc_str,
}
impl Default for sub_umbrella_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sub_library_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub sub_library: lc_str,
}
impl Default for sub_library_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prebound_dylib_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub name: lc_str,
    pub nmodules: u32,
    pub linked_modules: lc_str,
}
impl Default for prebound_dylib_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dylinker_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub name: lc_str,
}
impl Default for dylinker_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct thread_command {
    pub cmd: u32,
    pub cmdsize: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct routines_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub init_address: u32,
    pub init_module: u32,
    pub reserved1: u32,
    pub reserved2: u32,
    pub reserved3: u32,
    pub reserved4: u32,
    pub reserved5: u32,
    pub reserved6: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct routines_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub init_address: u64,
    pub init_module: u64,
    pub reserved1: u64,
    pub reserved2: u64,
    pub reserved3: u64,
    pub reserved4: u64,
    pub reserved5: u64,
    pub reserved6: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct symtab_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub symoff: u32,
    pub nsyms: u32,
    pub stroff: u32,
    pub strsize: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dysymtab_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub ilocalsym: u32,
    pub nlocalsym: u32,
    pub iextdefsym: u32,
    pub nextdefsym: u32,
    pub iundefsym: u32,
    pub nundefsym: u32,
    pub tocoff: u32,
    pub ntoc: u32,
    pub modtaboff: u32,
    pub nmodtab: u32,
    pub extrefsymoff: u32,
    pub nextrefsyms: u32,
    pub indirectsymoff: u32,
    pub nindirectsyms: u32,
    pub extreloff: u32,
    pub nextrel: u32,
    pub locreloff: u32,
    pub nlocrel: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dylib_table_of_contents {
    pub symbol_index: u32,
    pub module_index: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dylib_module {
    pub module_name: u32,
    pub iextdefsym: u32,
    pub nextdefsym: u32,
    pub irefsym: u32,
    pub nrefsym: u32,
    pub ilocalsym: u32,
    pub nlocalsym: u32,
    pub iextrel: u32,
    pub nextrel: u32,
    pub iinit_iterm: u32,
    pub ninit_nterm: u32,
    pub objc_module_info_addr: u32,
    pub objc_module_info_size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dylib_module_64 {
    pub module_name: u32,
    pub iextdefsym: u32,
    pub nextdefsym: u32,
    pub irefsym: u32,
    pub nrefsym: u32,
    pub ilocalsym: u32,
    pub nlocalsym: u32,
    pub iextrel: u32,
    pub nextrel: u32,
    pub iinit_iterm: u32,
    pub ninit_nterm: u32,
    pub objc_module_info_size: u32,
    pub objc_module_info_addr: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dylib_reference {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl dylib_reference {
    #[inline]
    pub fn isym(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_isym(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isym: u32, flags: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let isym: u32 = unsafe { ::std::mem::transmute(isym) };
            isym as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct twolevel_hints_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub offset: u32,
    pub nhints: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct twolevel_hint {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl twolevel_hint {
    #[inline]
    pub fn isub_image(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_isub_image(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn itoc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_itoc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(isub_image: u32, itoc: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let isub_image: u32 = unsafe { ::std::mem::transmute(isub_image) };
            isub_image as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let itoc: u32 = unsafe { ::std::mem::transmute(itoc) };
            itoc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct prebind_cksum_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub cksum: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct uuid_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub uuid: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rpath_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub path: lc_str,
}
impl Default for rpath_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linkedit_data_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub dataoff: u32,
    pub datasize: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct encryption_info_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub cryptoff: u32,
    pub cryptsize: u32,
    pub cryptid: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct encryption_info_command_64 {
    pub cmd: u32,
    pub cmdsize: u32,
    pub cryptoff: u32,
    pub cryptsize: u32,
    pub cryptid: u32,
    pub pad: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct version_min_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub version: u32,
    pub sdk: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct build_version_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub platform: u32,
    pub minos: u32,
    pub sdk: u32,
    pub ntools: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct build_tool_version {
    pub tool: u32,
    pub version: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dyld_info_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub rebase_off: u32,
    pub rebase_size: u32,
    pub bind_off: u32,
    pub bind_size: u32,
    pub weak_bind_off: u32,
    pub weak_bind_size: u32,
    pub lazy_bind_off: u32,
    pub lazy_bind_size: u32,
    pub export_off: u32,
    pub export_size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linker_option_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub count: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct symseg_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub offset: u32,
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ident_command {
    pub cmd: u32,
    pub cmdsize: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fvmfile_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub name: lc_str,
    pub header_addr: u32,
}
impl Default for fvmfile_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct entry_point_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub entryoff: u64,
    pub stacksize: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct source_version_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub version: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct data_in_code_entry {
    pub offset: u32,
    pub length: u16,
    pub kind: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tlv_descriptor {
    pub thunk: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut tlv_descriptor) -> *mut ::std::os::raw::c_void,
    >,
    pub key: ::std::os::raw::c_ulong,
    pub offset: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct note_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub data_owner: [::std::os::raw::c_char; 16usize],
    pub offset: u64,
    pub size: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fileset_entry_command {
    pub cmd: u32,
    pub cmdsize: u32,
    pub vmaddr: u64,
    pub fileoff: u64,
    pub entry_id: lc_str,
    pub reserved: u32,
}
impl Default for fileset_entry_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
