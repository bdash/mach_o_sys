/* automatically generated by rust-bindgen 0.70.1 */

#![allow(
    dead_code,
    non_camel_case_types,
    non_upper_case_globals,
    non_snake_case
)]
extern crate libc;
use self::libc::{mach_port_t, uuid_t};
use crate::loader::mach_header;

pub const DYLD_AOT_IMAGE_KEY_SIZE: u32 = 32;
pub const DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT: u32 = 8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum dyld_image_mode {
    dyld_image_adding = 0,
    dyld_image_removing = 1,
    dyld_image_info_change = 2,
    dyld_image_dyld_moved = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dyld_image_info {
    pub imageLoadAddress: *mut mach_header,
    pub imageFilePath: *const ::std::os::raw::c_char,
    pub imageFileModDate: usize,
}
impl Default for dyld_image_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct dyld_uuid_info {
    pub imageLoadAddress: *const mach_header,
    pub imageUUID: uuid_t,
}
impl Default for dyld_uuid_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dyld_aot_image_info {
    pub x86LoadAddress: *const mach_header,
    pub aotLoadAddress: *const mach_header,
    pub aotImageSize: u64,
    pub aotImageKey: [u8; 32usize],
}
impl Default for dyld_aot_image_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct dyld_aot_shared_cache_info {
    pub cacheBaseAddress: usize,
    pub cacheUUID: uuid_t,
}
impl Default for dyld_aot_shared_cache_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type dyld_image_notifier = ::std::option::Option<
    unsafe extern "C" fn(mode: dyld_image_mode, infoCount: u32, info: *const dyld_image_info),
>;
pub const dyld_error_kind_none: _bindgen_ty_2 = _bindgen_ty_2::dyld_error_kind_none;
pub const dyld_error_kind_dylib_missing: _bindgen_ty_2 =
    _bindgen_ty_2::dyld_error_kind_dylib_missing;
pub const dyld_error_kind_dylib_wrong_arch: _bindgen_ty_2 =
    _bindgen_ty_2::dyld_error_kind_dylib_wrong_arch;
pub const dyld_error_kind_dylib_version: _bindgen_ty_2 =
    _bindgen_ty_2::dyld_error_kind_dylib_version;
pub const dyld_error_kind_symbol_missing: _bindgen_ty_2 =
    _bindgen_ty_2::dyld_error_kind_symbol_missing;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    dyld_error_kind_none = 0,
    dyld_error_kind_dylib_missing = 1,
    dyld_error_kind_dylib_wrong_arch = 2,
    dyld_error_kind_dylib_version = 3,
    dyld_error_kind_symbol_missing = 4,
}
#[repr(C)]
#[repr(align(16))]
pub struct dyld_all_image_infos {
    pub version: u32,
    pub infoArrayCount: u32,
    pub infoArray: *const dyld_image_info,
    pub notification: dyld_image_notifier,
    pub processDetachedFromSharedRegion: bool,
    pub libSystemInitialized: bool,
    pub dyldImageLoadAddress: *const mach_header,
    pub jitInfo: *mut ::std::os::raw::c_void,
    pub dyldVersion: *const ::std::os::raw::c_char,
    pub errorMessage: *const ::std::os::raw::c_char,
    pub terminationFlags: usize,
    pub coreSymbolicationShmPage: *mut ::std::os::raw::c_void,
    pub systemOrderFlag: usize,
    pub uuidArrayCount: usize,
    pub uuidArray: *const dyld_uuid_info,
    pub dyldAllImageInfosAddress: *mut dyld_all_image_infos,
    pub initialImageCount: usize,
    pub errorKind: usize,
    pub errorClientOfDylibPath: *const ::std::os::raw::c_char,
    pub errorTargetDylibPath: *const ::std::os::raw::c_char,
    pub errorSymbol: *const ::std::os::raw::c_char,
    pub sharedCacheSlide: usize,
    pub sharedCacheUUID: [u8; 16usize],
    pub sharedCacheBaseAddress: usize,
    pub infoArrayChangeTimestamp: u64,
    pub dyldPath: *const ::std::os::raw::c_char,
    pub notifyPorts: [mach_port_t; 8usize],
    pub reserved: [usize; 7usize],
    pub sharedCacheFSID: u64,
    pub sharedCacheFSObjID: u64,
    pub compact_dyld_image_info_addr: usize,
    pub compact_dyld_image_info_size: usize,
    pub platform: u32,
    pub aotInfoCount: u32,
    pub aotInfoArray: *const dyld_aot_image_info,
    pub aotInfoArrayChangeTimestamp: u64,
    pub aotSharedCacheBaseAddress: usize,
    pub aotSharedCacheUUID: [u8; 16usize],
}
impl Default for dyld_all_image_infos {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dyld_shared_cache_ranges {
    pub sharedRegionsCount: usize,
    pub ranges: [dyld_shared_cache_ranges__bindgen_ty_1; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dyld_shared_cache_ranges__bindgen_ty_1 {
    pub start: usize,
    pub length: usize,
}
extern "C" {
    pub static mut dyld_shared_cache_ranges: dyld_shared_cache_ranges;
}
